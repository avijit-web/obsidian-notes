---
tags:
  - database
  - typescript
  - typeorm
  - backend
---

# 📁Suggested Node.js + TypeScript Project Structure

```bash
my-node-project/
├── src/
│   ├── entity/                  # Database entities (models)
│   │   └── User.ts
│   ├── migration/               # Database migrations
│   ├── controller/              # API route handlers (controllers)
│   │   └── UserController.ts
│   ├── service/                 # Business logic (service layer)
│   │   └── UserService.ts
│   ├── config/                  # Configuration files (e.g., database connection)
│   │   └── database.ts
│   ├── routes/                  # Route definitions
│   │   └── userRoutes.ts
│   ├── app.ts                   # Express app setup
│   └── index.ts                 # Application entry point
├── dist/                        # Compiled JavaScript files (generated by TypeScript)
├── node_modules/                # Project dependencies
├── .env                         # Environment variables
├── .gitignore                   # Files and folders to ignore in version control
├── ormconfig.json               # TypeORM configuration
├── package.json                 # Project metadata and dependencies
├── tsconfig.json                # TypeScript configuration

```
``

# 🛠️ Setting Up TypeORM and Database Connection

## 1. 📦 Installing TypeORM and Necessary Dependencies

To use **TypeORM** in your project, you need to install the ORM library along with the appropriate database driver based on your chosen database.

---

### 🐘 For PostgreSQL:

```bash
# Open your terminal and navigate to your project directory
npm install typeorm reflect-metadata pg
# Open your terminal and navigate to your project directory
npm install typeorm reflect-metadata mysql2

```

# 🧱 TypeORM Data Source Setup (`data-source.ts`)

Create a new file named `data-source.ts` in the `src` directory.

```ts
import { DataSource } from 'typeorm';
import { User } from './entity/User'; // Adjust the import to your entities

const AppDataSource = new DataSource({
  type: "postgres", // or "mysql"
  host: process.env.DB_HOST,
  port: Number(process.env.DB_PORT),
  username: process.env.DB_USERNAME,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  synchronize: true, // Set to false in production
  logging: true,
  entities: [User],
  migrations: [],
});

export default AppDataSource;
```
``

# 🧩 TypeORM Decorators Cheatsheet

TypeORM provides various decorators to define entity properties and relationships effectively.  
Here are some commonly used decorators:

---

## 🧱 Entity & Column Decorators

### `@Entity(name?: string)`
Marks a class as an entity. The optional `name` parameter defines the table name.

### `@PrimaryGeneratedColumn()`
Used for primary keys that auto-increment.

### `@PrimaryColumn()`
Used for manually assigned (non-generated) primary keys.

### `@Column(options?: ColumnOptions)`
Defines a column in the table. The options parameter can specify:
- `type`: Data type (e.g., `String`, `Number`, `Boolean`, etc.)
- `length`: Length for string types
- `nullable`: Whether the column can be null
- `default`: Default value for the column

---

## 🔗 Relationship Decorators

### `@ManyToOne()`
Defines a many-to-one relationship with another entity.

### `@OneToMany()`
Defines a one-to-many relationship with another entity.

### `@ManyToMany()`
Defines a many-to-many relationship between two entities.

### `@OneToOne()`
Defines a one-to-one relationship with another entity.

### `@JoinColumn()`
Specifies the column that joins two entities in a relationship.

---

## 📌 Next

See the section “Example of Relationships” for practical code examples.


# 👤 User & 📝 Post Entity Example (TypeORM)

```ts
// src/entity/User.ts
import { Entity, PrimaryGeneratedColumn, Column, OneToMany, CreateDateColumn, UpdateDateColumn } from 'typeorm';
import { Post } from './Post';

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ length: 100 })
  firstName: string;

  @Column({ length: 100 })
  lastName: string;

  @Column({ unique: true })
  email: string;

  @Column({ default: true })
  isActive: boolean;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  @OneToMany(() => Post, post => post.author)
  posts: Post[];
}

// src/entity/Post.ts
import { Entity, PrimaryGeneratedColumn, Column, ManyToOne, CreateDateColumn, UpdateDateColumn } from 'typeorm';
import { User } from './User';

@Entity()
export class Post {
  @PrimaryGeneratedColumn()
  id: number;

  @Column('text')
  content: string;

  @Column({ nullable: true })
  title: string;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  @ManyToOne(() => User, user => user.posts, { onDelete: 'CASCADE' })
  author: User;
}

```


---

## 🔧 How It Works

- `User` is linked to multiple `Post` instances via `@OneToMany()`, and each `Post` references a `User` via `@ManyToOne()`—creating a classic one‑to‑many relationship.
- Decorators like `@PrimaryGeneratedColumn()`, `@Column()`, `@CreateDateColumn()`, and `@UpdateDateColumn()` mark up entity properties to be mapped to database fields automatically (such as timestamps and autogenerated IDs). 
- Relationship decorators (`@OneToMany`, `@ManyToOne`) define the direction of the relation. `onDelete: 'CASCADE'` ensures posts are removed when their user is deleted. 

---

## ✅ Usage Tips

1. Ensure both entities (`User`, `Post`) are registered in your `DataSource` configuration.
2. Use TypeScript generators and decorators, and don't forget to include `reflect-metadata` at the entry point.
3. You can add more advanced decorators like `@Unique()`, `@Index()`, or custom listeners (`@BeforeInsert`, `@AfterLoad`, etc.) if needed.

## 🛠️ TypeORM Data Source Initialization

```ts
// data-source.ts
import { DataSource } from 'typeorm';
import { User } from './entity/User';

const AppDataSource = new DataSource({
  type: 'postgres',
  host: process.env.DB_HOST,
  port: Number(process.env.DB_PORT),
  username: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  synchronize: true, // Set to false in production
  logging: true,
  entities: [User],
  migrations: [],
});

export default AppDataSource;

// index.ts or app.ts
import 'reflect-metadata'; // Import reflect-metadata at the top
import AppDataSource from './data-source';

const startApp = async () => {
  await AppDataSource.initialize()
    .then(() => {
      console.log('Data Source has been initialized!');
    })
    .catch((err) => {
      console.error('Error during Data Source initialization', err);
    });
};

startApp();

```
```
```



This setup ensures that:
- `reflect-metadata` is loaded (mandatory for decorators).
- Your database connection is established before starting the app.
- Errors during setup are logged for debugging.


