---
tags:
  - database
  - typescript
  - typeorm
  - backend
---

# ðŸ“Suggested Node.js + TypeScript Project Structure

```bash
my-node-project/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ entity/                  # Database entities (models)
â”‚   â”‚   â””â”€â”€ User.ts
â”‚   â”œâ”€â”€ migration/               # Database migrations
â”‚   â”œâ”€â”€ controller/              # API route handlers (controllers)
â”‚   â”‚   â””â”€â”€ UserController.ts
â”‚   â”œâ”€â”€ service/                 # Business logic (service layer)
â”‚   â”‚   â””â”€â”€ UserService.ts
â”‚   â”œâ”€â”€ config/                  # Configuration files (e.g., database connection)
â”‚   â”‚   â””â”€â”€ database.ts
â”‚   â”œâ”€â”€ routes/                  # Route definitions
â”‚   â”‚   â””â”€â”€ userRoutes.ts
â”‚   â”œâ”€â”€ app.ts                   # Express app setup
â”‚   â””â”€â”€ index.ts                 # Application entry point
â”œâ”€â”€ dist/                        # Compiled JavaScript files (generated by TypeScript)
â”œâ”€â”€ node_modules/                # Project dependencies
â”œâ”€â”€ .env                         # Environment variables
â”œâ”€â”€ .gitignore                   # Files and folders to ignore in version control
â”œâ”€â”€ ormconfig.json               # TypeORM configuration
â”œâ”€â”€ package.json                 # Project metadata and dependencies
â”œâ”€â”€ tsconfig.json                # TypeScript configuration

```
``

# ðŸ› ï¸ Setting Up TypeORM and Database Connection

## 1. ðŸ“¦ Installing TypeORM and Necessary Dependencies

To use **TypeORM** in your project, you need to install the ORM library along with the appropriate database driver based on your chosen database.

---

### ðŸ˜ For PostgreSQL:

```bash
# Open your terminal and navigate to your project directory
npm install typeorm reflect-metadata pg
# Open your terminal and navigate to your project directory
npm install typeorm reflect-metadata mysql2

```

# ðŸ§± TypeORM Data Source Setup (`data-source.ts`)

Create a new file named `data-source.ts` in the `src` directory.

```ts
import { DataSource } from 'typeorm';
import { User } from './entity/User'; // Adjust the import to your entities

const AppDataSource = new DataSource({
  type: "postgres", // or "mysql"
  host: process.env.DB_HOST,
  port: Number(process.env.DB_PORT),
  username: process.env.DB_USERNAME,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  synchronize: true, // Set to false in production
  logging: true,
  entities: [User],
  migrations: [],
});

export default AppDataSource;
```
``

# ðŸ§© TypeORM Decorators Cheatsheet

TypeORM provides various decorators to define entity properties and relationships effectively.  
Here are some commonly used decorators:

---

## ðŸ§± Entity & Column Decorators

### `@Entity(name?: string)`
Marks a class as an entity. The optional `name` parameter defines the table name.

### `@PrimaryGeneratedColumn()`
Used for primary keys that auto-increment.

### `@PrimaryColumn()`
Used for manually assigned (non-generated) primary keys.

### `@Column(options?: ColumnOptions)`
Defines a column in the table. The options parameter can specify:
- `type`: Data type (e.g., `String`, `Number`, `Boolean`, etc.)
- `length`: Length for string types
- `nullable`: Whether the column can be null
- `default`: Default value for the column

---

## ðŸ”— Relationship Decorators

### `@ManyToOne()`
Defines a many-to-one relationship with another entity.

### `@OneToMany()`
Defines a one-to-many relationship with another entity.

### `@ManyToMany()`
Defines a many-to-many relationship between two entities.

### `@OneToOne()`
Defines a one-to-one relationship with another entity.

### `@JoinColumn()`
Specifies the column that joins two entities in a relationship.

---

## ðŸ“Œ Next

See the section â€œExample of Relationshipsâ€ for practical code examples.


# ðŸ‘¤ User & ðŸ“ Post Entity Example (TypeORM)

```ts
// src/entity/User.ts
import { Entity, PrimaryGeneratedColumn, Column, OneToMany, CreateDateColumn, UpdateDateColumn } from 'typeorm';
import { Post } from './Post';

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ length: 100 })
  firstName: string;

  @Column({ length: 100 })
  lastName: string;

  @Column({ unique: true })
  email: string;

  @Column({ default: true })
  isActive: boolean;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  @OneToMany(() => Post, post => post.author)
  posts: Post[];
}

// src/entity/Post.ts
import { Entity, PrimaryGeneratedColumn, Column, ManyToOne, CreateDateColumn, UpdateDateColumn } from 'typeorm';
import { User } from './User';

@Entity()
export class Post {
  @PrimaryGeneratedColumn()
  id: number;

  @Column('text')
  content: string;

  @Column({ nullable: true })
  title: string;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  @ManyToOne(() => User, user => user.posts, { onDelete: 'CASCADE' })
  author: User;
}

```


---

## ðŸ”§ How It Works

- `User` is linked to multiple `Post` instances via `@OneToMany()`, and each `Post` references a `User` via `@ManyToOne()`â€”creating a classic oneâ€‘toâ€‘many relationship.
- Decorators like `@PrimaryGeneratedColumn()`, `@Column()`, `@CreateDateColumn()`, and `@UpdateDateColumn()` mark up entity properties to be mapped to database fields automatically (such as timestamps and autogenerated IDs). 
- Relationship decorators (`@OneToMany`, `@ManyToOne`) define the direction of the relation. `onDelete: 'CASCADE'` ensures posts are removed when their user is deleted. 

---

## âœ… Usage Tips

1. Ensure both entities (`User`, `Post`) are registered in your `DataSource` configuration.
2. Use TypeScript generators and decorators, and don't forget to include `reflect-metadata` at the entry point.
3. You can add more advanced decorators like `@Unique()`, `@Index()`, or custom listeners (`@BeforeInsert`, `@AfterLoad`, etc.) if needed.

## ðŸ› ï¸ TypeORM Data Source Initialization

```ts
// data-source.ts
import { DataSource } from 'typeorm';
import { User } from './entity/User';

const AppDataSource = new DataSource({
  type: 'postgres',
  host: process.env.DB_HOST,
  port: Number(process.env.DB_PORT),
  username: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  synchronize: true, // Set to false in production
  logging: true,
  entities: [User],
  migrations: [],
});

export default AppDataSource;

// index.ts or app.ts
import 'reflect-metadata'; // Import reflect-metadata at the top
import AppDataSource from './data-source';

const startApp = async () => {
  await AppDataSource.initialize()
    .then(() => {
      console.log('Data Source has been initialized!');
    })
    .catch((err) => {
      console.error('Error during Data Source initialization', err);
    });
};

startApp();

```
```
```



This setup ensures that:
- `reflect-metadata` is loaded (mandatory for decorators).
- Your database connection is established before starting the app.
- Errors during setup are logged for debugging.


